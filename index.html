<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulaci√≥n de Empaque 3D</title>
    <style>
        body { margin: 0; overflow: hidden; }
        #canvas-container { width: 100vw; height: 100vh; }
        .controls { position: absolute; top: 10px; left: 10px; z-index: 100; color: #39ff14; }
        .controls input, .controls button { display: block; margin-bottom: 10px; color: #39ff14; background-color: black; border: 1px solid #39ff14; }
        .controls label { color: #39ff14; }
        .container-icons { display: flex; gap: 5px; margin-top: 10px; }
        .container-icon { width: 20px; height: 20px; background-color: #39ff14; cursor: pointer; }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <div class="controls">
        <label>Ancho del Contenedor: <input type="number" id="containerWidth" value="100"></label>
        <label>Alto del Contenedor: <input type="number" id="containerHeight" value="100"></label>
        <label>Profundidad del Contenedor: <input type="number" id="containerDepth" value="100"></label>
        <button id="updateContainer">Actualizar Contenedor</button>
        <label>Ancho de la Caja: <input type="number" id="boxWidth" value="10"></label>
        <label>Alto de la Caja: <input type="number" id="boxHeight" value="10"></label>
        <label>Profundidad de la Caja: <input type="number" id="boxDepth" value="10"></label>
        <button id="addBox">Agregar Caja</button>
        <button id="rearrange">Reacomodar Cajas</button>
        <div id="boxCount">Cajas creadas: 0</div>
        <div id="containerCount">Contenedores creados: 1</div>
        <div class="container-icons" id="containerIcons"></div>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer;
        let containers = [];
        let boxes = [];
        let controls = {
            containerWidth: 100,
            containerHeight: 100,
            containerDepth: 100
        };

        let boxCount = 0;

        init();
        animate();

        function init() {
            // Scene setup
            scene = new THREE.Scene();
            
            // Camera setup
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 200;
            
            // Renderer setup
            renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Create initial container and boxes
            createContainer();
            createBoxes();

            // Event listeners
            document.getElementById('updateContainer').addEventListener('click', updateContainer);
            document.getElementById('rearrange').addEventListener('click', rearrangeBoxes);
            document.getElementById('addBox').addEventListener('click', addBox);
            
            // Mouse controls for rotating the scene
            let isDragging = false;
            let previousMousePosition = {
                x: 0,
                y: 0
            };

            renderer.domElement.addEventListener('mousedown', function(e) {
                isDragging = true;
            });

            renderer.domElement.addEventListener('mousemove', function(e) {
                let deltaMove = {
                    x: e.offsetX - previousMousePosition.x,
                    y: e.offsetY - previousMousePosition.y
                };

                if (isDragging) {
                    let deltaRotationQuaternion = new THREE.Quaternion()
                        .setFromEuler(new THREE.Euler(
                            toRadians(deltaMove.y * 1),
                            toRadians(deltaMove.x * 1),
                            0,
                            'XYZ'
                        ));

                    scene.quaternion.multiplyQuaternions(deltaRotationQuaternion, scene.quaternion);
                }

                previousMousePosition = {
                    x: e.offsetX,
                    y: e.offsetY
                };
            });

            document.addEventListener('mouseup', function(e) {
                isDragging = false;
            });
        }

        function toRadians(angle) {
            return angle * (Math.PI / 180);
        }

        function createContainer() {
            let geometry = new THREE.BoxGeometry(controls.containerWidth, controls.containerHeight, controls.containerDepth);
            let material = new THREE.MeshBasicMaterial({ color: 0x39ff14, wireframe: true });
            let container = new THREE.Mesh(geometry, material);
            containers.push(container);
            scene.add(container);
        }

        function createBoxes() {
            let boxSizes = [
                { width: 10, height: 10, depth: 10 },

                { width: 25, height: 25, depth: 25 },
                { width: 30, height: 30, depth: 30 }
            ];

            boxSizes.forEach(size => {
                for (let i = 0; i < 1; i++) {
                    let geometry = new THREE.BoxGeometry(size.width, size.height, size.depth);
                    let color = Math.random() * 0xffffff;
                    let material = new THREE.MeshBasicMaterial({ color: color });
                    let box = new THREE.Mesh(geometry, material);
                    boxes.push(box);
                    boxCount++;
                }
            });

            document.getElementById('boxCount').innerText = 'Cajas creadas: ' + boxCount;
            placeBoxes();
        }

        function addBox() {
            let width = parseFloat(document.getElementById('boxWidth').value);
            let height = parseFloat(document.getElementById('boxHeight').value);
            let depth = parseFloat(document.getElementById('boxDepth').value);
            
            let geometry = new THREE.BoxGeometry(width, height, depth);
            let color = Math.random() * 0xffffff;
            let material = new THREE.MeshBasicMaterial({ color: color });
            let box = new THREE.Mesh(geometry, material);
            boxes.push(box);
            boxCount++;
            
            document.getElementById('boxCount').innerText = 'Cajas creadas: ' + boxCount;
            placeBoxes();
        }

        function updateContainer() {
            controls.containerWidth = parseFloat(document.getElementById('containerWidth').value);
            controls.containerHeight = parseFloat(document.getElementById('containerHeight').value);
            controls.containerDepth = parseFloat(document.getElementById('containerDepth').value);
            
            containers.forEach(container => scene.remove(container));
            containers = [];
            createContainer();
            placeBoxes();
        }

        function rearrangeBoxes() {
            placeBoxes();
        }

        function placeBoxes() {
            // Remove all boxes from the scene
            boxes.forEach(box => scene.remove(box));
            
            // Calculate total volume of all boxes
            let totalBoxVolume = boxes.reduce((acc, box) => acc + box.geometry.parameters.width * box.geometry.parameters.height * box.geometry.parameters.depth, 0);
            let containerVolume = controls.containerWidth * controls.containerHeight * controls.containerDepth;
            
            // Calculate the number of required containers
            let requiredContainers = Math.ceil(totalBoxVolume / containerVolume);

            // Remove existing containers
            containers.forEach(container => scene.remove(container));
            containers = [];

            // Create required number of containers
            for (let i = 0; i < requiredContainers; i++) {
                let container = new THREE.Mesh(
                    new THREE.BoxGeometry(controls.containerWidth, controls.containerHeight, controls.containerDepth),
                    new THREE.MeshBasicMaterial({ color: 0x39ff14, wireframe: true })
                );
                container.position.set((i - Math.floor(requiredContainers / 2)) * (controls.containerWidth + 10), 0, 0);
                containers.push(container);
                scene.add(container);
            }

            // Update container count and icons
            document.getElementById('containerCount').innerText = 'Contenedores creados: ' + requiredContainers;
            updateContainerIcons(requiredContainers);

            // Place boxes in the containers using bin-packing heuristic
            boxes.sort((a, b) => b.geometry.parameters.width * b.geometry.parameters.height * b.geometry.parameters.depth - a.geometry.parameters.width * a.geometry.parameters.height * a.geometry.parameters.depth);

            let containerIndex = 0;
            let positions = [];

            boxes.forEach(box => {
                let placed = false;
                while (!placed && containerIndex < containers.length) {
                    let container = containers[containerIndex];
                    for (let x = -controls.containerWidth / 2; x <= controls.containerWidth / 2 - box.geometry.parameters.width; x++) {
                        for (let y = -controls.containerHeight / 2; y <= controls.containerHeight / 2 - box.geometry.parameters.height; y++) {
                            for (let z = -controls.containerDepth / 2; z <= controls.containerDepth / 2 - box.geometry.parameters.depth; z++) {
                                if (!positions.some(pos =>
                                    pos.containerIndex === containerIndex &&
                                    x < pos.x + pos.width &&
                                    x + box.geometry.parameters.width > pos.x &&
                                    y < pos.y + pos.height &&
                                    y + box.geometry.parameters.height > pos.y &&
                                    z < pos.z + pos.depth &&
                                    z + box.geometry.parameters.depth > pos.z
                                )) {
                                    box.position.set(
                                        x + box.geometry.parameters.width / 2,
                                        y + box.geometry.parameters.height / 2,
                                        z + box.geometry.parameters.depth / 2
                                    );
                                    container.add(box);
                                    positions.push({
                                        containerIndex: containerIndex,
                                        x: x,
                                        y: y,
                                        z: z,
                                        width: box.geometry.parameters.width,
                                        height: box.geometry.parameters.height,
                                        depth: box.geometry.parameters.depth
                                    });
                                    placed = true;
                                    break;
                                }
                            }
                            if (placed) break;
                        }
                        if (placed) break;
                    }
                    if (!placed) containerIndex++;
                }
            });
        }

        function updateContainerIcons(containerCount) {
            let containerIcons = document.getElementById('containerIcons');
            containerIcons.innerHTML = '';

            for (let i = 0; i < containerCount; i++) {
                let icon = document.createElement('div');
                icon.className = 'container-icon';
                icon.addEventListener('click', () => showContainer(i));
                containerIcons.appendChild(icon);
            }
        }

        function showContainer(index) {
            containers.forEach((container, i) => {
                container.visible = i === index;
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
